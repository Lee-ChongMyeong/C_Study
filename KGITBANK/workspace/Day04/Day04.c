#include <stdio.h>

// ---- 비트 연산자 ----
// 10진수를 2진수 형태로 각 비트별로 연산을 진행
// &(비트 AND 연산) : 대응되는 비트가 모두 1이면 1을 반환
// |(비트 OR 연산) : 대응되는 비트 중 하나라도 1이면 1을 반환
// ^(비트 XOR 연산) : 대응되는 비트가 서로 다르면 1을 반환
// ~(비트 NOT 연산) : 비트가 0이면 1, 1이면 0으로 반전  
// <<(left Shift 연산) : 비트들을 모두 지정 수 만큼 왼쪽으로 이동
// >>(Right Shift 연산) : 비트들을 모두 지정 수 만큼 오른쪽으로 이동
//
//
// 0101 0111 = 87 (10진법)
// 01 010 111 = 127 (8진법)
// 0101 0111 = 57 (16진법)
//
//             <10진법>          <8진법>   <16진법>
//  31      // 0001 1111        // 37      // 1F
//  62      // 0011 1110        // 76      // 3E
//  255     // 1111 1111        // 377     // FF 
//  10      // 0000 1010        // 12      // A
//  35      // 0010 0011        // 43      // 23
//  46      // 0010 1110        // 56      // 2E
//
//
//	0101 0111 = 87
//  & | ^ << >>
//  0011 0010 = 50
//  -----------------
//  0001 0010 = 18	 (AND)
//  0111 0111 = 119  (OR)
//  0110 0101 = 101  (XOR)
//  0011 0010 << 1 0110 0100 = 100 (Left Shift)
//  0101 0111 >> 1 0010 1011 = 21 (Right Shift)
//
//
// 0000 1010 = 10   [ 1의 보수 : 보충해주는 수 ]
// 1111 0101		-> 1의 보수
// 1111 0110		-> 2의 보수 (+1)
//
// 해당 값들을 2의 보수를 이용해 2진수로 표시하시오 
//
// -59  
// [0011 1011]	==>	1100 0101 
// -7   
// [0000 0111]  ==> 1111 1001
// -100 
// [0110 1011]  ==> 1001 1100	
   


int main() {

	printf("비트 AND 연산 결과 : %d\n", 87 & 50);
	printf("비트 OR 연산 결과 : %d\n", 87 | 50);
	printf("비트 XOR 연산 결과 : %d\n", 87 ^ 50);
	printf("Left Shift 연산 결과 : %d\n", 50 << 1 );
	printf("Right Shift 연산 결과 : %d\n\n", 87 >> 1);

//Q1 다음 코드의 출력 내용을 예상하시오.
	char num1 = 78, num2 = 37, num3 = 18;	// char : 8비트 저장할수 있는공안 이므로, 8비트 환경
	char num4 = 4, num5 = 106;				// 8비트 표현할수 있는 가장 큰 수는 0111 1111 ( 1 : 부호비트 (-))
	// unsigned char : 부호비트로서 사용하지 않고 + 만 사용하는 값.

	printf("%d\n", num1 | num3);	// 94
	printf("%d\n", num5 & num2);	// 32
	printf("%d\n", num4 ^ num3);	// 22	
	printf("%d\n", ~num4);			// -5
	printf("%d\n", (unsigned char)~num4);
	printf("%d\n", num4 << 3);		// 32
	printf("%d\n", num3 >> 1);		// 9


/*	  128 64 32 16 / 8 4 2 1
           1  1 0    1 0 1 0  */     

		 /*
		   num1 = 0100 1110
		   num2 = 0010 0101
		   num3 = 0001 0010 
		   num4 = 0000 0100
		   num5 = 0110 1010
		           
				  0101 1110 94
				  0010 0000 32
				  0001 0110 22
				  1111 1011 251
				  -> 0000 0101 -5 
		          0010 0000 32
		          0000 1001 9 */

	return 0;
}